<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Setting up the Environment</title>
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f7f9fc;
            color: #333;
        }

        header {
            background: #0056b3;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }

        nav {
            background: #004494;
            padding: 10px;
            color: white;
            text-align: right;
        }

        nav a {
            color: #fff;
            text-decoration: none;
            margin: 0 10px;
        }

        nav a:hover {
            text-decoration: underline;
        }

        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        h1 {
            font-size: 28px;
            color: #0056b3;
        }

        h2 {
            font-size: 22px;
            color: #0056b3;
            margin-top: 20px;
        }

        h3 {
            font-size: 18px;
            color: #004494;
            margin-top: 20px;
        }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, "Courier New", monospace;
            font-size: 14px;
        }

        code {
            color: #c586c0;
            background: #1e1e1e;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .python-code {
            color: #dcdcaa;
        }

        .note {
            background: #fdf4d3;
            border-left: 6px solid #ffd700;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        a {
            color: #0056b3;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            font-size: 14px;
            color: #777;
            padding: 10px;
            background: #f3f4f6;
        }

        footer a {
            color: #0056b3;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Additional styling for details (collapsible solutions) */
        details {
            margin: 10px 0;
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px;
        }

        details summary {
            cursor: pointer;
            font-weight: bold;
            outline: none;
        }

        details[open] summary {
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <header>
        CSCI 384 - Artificial Intelligence
    </header>

    <nav>
        <a href="#">Course Schedule</a>
        <a href="python_tutorial.html">Python Tutorial</a>
    </nav>

    <div class="container">
        <h1>Python Jupyter Lab Extended Tutorial</h1>

        <!-- ********************************************
             ADDITIONAL INSTRUCTIONS ON HOW TO USE JUPYTER LAB
             ******************************************** -->
        <section>
            <h2>How to Write and Execute Python Code in Jupyter Lab</h2>
            <p>
                Jupyter Lab is an interactive environment that allows you to write and run Python (and other) code in
                separate cells. Here is a simple guide to get started:
            </p>
            <ol>
                <li><strong>Launch Jupyter Lab:</strong> From a terminal (or Anaconda prompt), run:
                    <pre>jupyter lab</pre>
                    This will open Jupyter Lab in your browser.
                </li>
                <li><strong>Create a New Notebook:</strong> In the Jupyter Lab interface, go to
                    <em>File &gt; New &gt; Notebook</em>.
                    Choose <em>Python 3</em> (or your preferred environment) as the kernel.
                </li>
                <li><strong>Write Code in a Cell:</strong> Click inside a cell and type your Python code. For example:
                    <pre>print("Hello, Jupyter Lab!")</pre>
                </li>
                <li><strong>Run a Cell:</strong> Press <code>Shift + Enter</code> to run the cell. Jupyter Lab will
                    display
                    the output right below the cell.
                </li>
                <li><strong>Add New Cells:</strong> Use the toolbar buttons or keyboard shortcuts (<code>Esc + A</code>
                    to
                    add a cell above, <code>Esc + B</code> to add a cell below) to insert more cells.
                </li>
                <li><strong>Save Your Notebook:</strong> Use <code>Ctrl + S</code> (Command + S on macOS) or click the
                    <em>Save</em> icon.
                </li>
            </ol>
            <p>
                Once you are comfortable with these basics, you can start exploring more advanced features such as
                integrated terminals, extension manager, and interactive visualizations.
            </p>
        </section>

        <h2>Step 14: Transitioning to Jupyter Lab</h2>
        <p>Congratulations! Your Jupyter Lab is now up and running. In this extended tutorial, we will dive deeper into
            its features, provide advanced tips, and explore how to use Jupyter Lab effectively for developing AI games.
        </p>

        <h2>15. Essential Features of Jupyter Lab</h2>
        <h3>15.1 Integrated File Browser</h3>
        <p>The file browser in Jupyter Lab is a game-changer for managing your project files. Features include:</p>
        <ul>
            <li>Creating, renaming, and deleting files.</li>
            <li>Dragging and dropping files for organization.</li>
            <li>Launching terminals or notebooks directly from the browser.</li>
        </ul>

        <h3>15.2 Multi-Tab Interface</h3>
        <p>Jupyter Lab supports a multi-tab interface, allowing you to:</p>
        <ul>
            <li>Work on multiple notebooks side-by-side.</li>
            <li>View documentation and code simultaneously.</li>
            <li>Drag and arrange tabs for better workflow.</li>
        </ul>

        <h3>15.3 Built-in Terminals</h3>
        <p>Use the terminal to execute shell commands without leaving Jupyter Lab:</p>
        <pre>!pip install scikit-learn</pre>

        <h3>15.4 Extension Manager</h3>
        <p>Enhance functionality by installing extensions:</p>
        <pre>jupyter labextension install @jupyterlab/git</pre>
        <p>This example installs Git integration, enabling version control directly within Jupyter Lab.</p>

        <h3>15.5 Rich Output Support</h3>
        <p>Jupyter Lab supports rich output, including:</p>
        <ul>
            <li>Interactive plots with libraries like <code>matplotlib</code> and <code>plotly</code>.</li>
            <li>Inline visualizations for machine learning models.</li>
            <li>Embedded HTML, videos, and images.</li>
        </ul>

        <h2>16. Tips and Tricks for Effective Usage</h2>
        <h3>16.1 Keyboard Shortcuts</h3>
        <p>Master these shortcuts for efficiency:</p>
        <ul>
            <li><code>Shift + Enter</code> Run the current cell and move to the next.</li>
            <li><code>Ctrl + S</code> Save your notebook.</li>
            <li><code>Esc + A</code> Insert a cell above.</li>
            <li><code>Esc + B</code> Insert a cell below.</li>
        </ul>

        <h3>16.2 Magic Commands</h3>
        <p>Use magic commands for additional functionality:</p>
        <pre>%timeit -n 10 [x**2 for x in range(1000)]</pre>
        <p>This measures the execution time of the code.</p>

        <h3>16.3 Debugging Tips</h3>
        <ul>
            <li>Use <code>print()</code> statements to inspect variables.</li>
            <li>Leverage the built-in debugger by adding <code>%debug</code> after an exception.</li>
        </ul>

        <h2>17. Developing AI Games in Jupyter Lab</h2>
        <h3>17.1 Setting Up the Environment</h3>
        <p>Install the required libraries:</p>
        <pre>!pip install pygame numpy matplotlib</pre>

        <h3>17.2 Creating a Simple Game</h3>
        <pre class="python-code">
import pygame  # Imports the Pygame library, which provides functionalities for 2D game development in Python
import sys     # Imports the sys library for system-related functionalities (e.g., sys.exit())

# Initialize pygame
pygame.init()  
# Initializes all Pygame modules. 
# This should be called before using most Pygame functions.

# Set up display
screen = pygame.display.set_mode((600, 400))
# Creates a game window of width 600 and height 400 pixels.
# Returns a 'Surface' object where all drawing (images, shapes, text) will occur.

pygame.display.set_caption("Simple AI Game")
# Sets the title of the window to "Simple AI Game".

# Game loop
running = True
# A Boolean variable that we will use to control when our game should stop.

while running:
    # The main game loop. This will continue to run until 'running' is set to False.

    for event in pygame.event.get():
        # Retrieves and iterates through the list of events (e.g., key presses, mouse clicks).
        
        if event.type == pygame.QUIT:
            # If the user clicks the 'X' button on the window...
            running = False
            # ...we set 'running' to False, which will break us out of the main loop.

    screen.fill((0, 0, 0))
    # Fills the screen with black color (RGB: 0, 0, 0).
    # This clears the previous frame's drawings.

    pygame.display.flip()
    # Updates the entire screen surface to display whatever we've drawn.

# Once the loop is exited (running = False):
pygame.quit()
# Uninitializes all Pygame modules and frees up any system resources used.

sys.exit()
# Exits the program using the sys module (optional but often used to cleanly close the script).

        </pre>

        <h3>17.3 Adding AI Logic</h3>
        <p>Implement AI decision-making with algorithms like minimax:</p>
        <pre class="python-code">
def minimax(state, depth, maximizing_player):
    """
    A recursive minimax function that explores game states up to a certain depth 
    and returns the best possible score for either the maximizing or minimizing player.

    Args:
        state (object): The current game state. This could be a board configuration, 
                        a set of moves, or any structure representing the state of the game.
        depth (int): How many levels deep to explore in the game tree. 
                     When depth is 0, or the state is a terminal state, the recursion ends.
        maximizing_player (bool): A flag indicating if we are currently optimizing for 
                                  the "maximizing player" or the "minimizing player".

    Returns:
        float: The best evaluated score for the current branch of the game tree.
    """

    if depth == 0 or is_terminal(state):
        # Base condition of the recursion:
        # 1) If depth == 0, we've reached the maximum depth to explore.
        # 2) If the state is terminal (e.g., a win/loss/draw in a game), no further exploration is needed.
        return evaluate(state)
        # evaluate(state) is presumably a function that scores the state. 
        # Example: In a game of tic-tac-toe, it might return +1 if X wins, -1 if O wins, 0 if it's a draw.

    if maximizing_player:
        # Branch of logic for the maximizing player:
        # We assume this player wants to maximize the score.
        max_eval = float('-inf')  
        # Initialize best evaluation to negative infinity, so any real value will be higher.

        for child in get_children(state):
            # Iterate over each possible next state (child) of the current state.
            eval = minimax(child, depth - 1, False)
            # Recursively call minimax on the child, decreasing depth by 1.
            # Now set maximizing_player to False, because the next level would be the minimizing player's turn.
            max_eval = max(max_eval, eval)
            # Update the best (maximum) score if the current child's evaluation is higher.
        
        return max_eval
        # Return the best score found for the maximizing player.

    else:
        # Branch of logic for the minimizing player:
        # We assume this player wants to minimize the score.
        min_eval = float('inf')
        # Initialize best evaluation to positive infinity, so any real value will be lower.

        for child in get_children(state):
            # Iterate over each possible next state (child) of the current state.
            eval = minimax(child, depth - 1, True)
            # Recursively call minimax on the child, decreasing depth by 1.
            # Now set maximizing_player to True, because the next level is the maximizing player's turn.
            min_eval = min(min_eval, eval)
            # Update the best (minimum) score if the current child's evaluation is lower.
        
        return min_eval
        # Return the best score found for the minimizing player.

        </pre>

        <h3>17.4 Visualizing Game States</h3>
        <p>Use <code>matplotlib</code> to visualize game states or AI decisions:</p>
        <pre class="python-code">
import matplotlib.pyplot as plt  
# Imports the plotting library "matplotlib" under the alias "plt".
# Commonly used for creating static, animated, or interactive visualizations in Python.

game_states = [1, 2, 3, 4, 5]
# A list representing discrete stages, levels, or states in a game or simulation.
# Example: These might represent rounds in a game, or different stages of an AI algorithm.

performance = [10, 20, 15, 25, 30]
# A list representing performance metrics (e.g., scores, time taken, or other measures).
# The first value (10) corresponds to game state 1, the second (20) to game state 2, etc.

plt.plot(game_states, performance)
# Creates a line plot with 'game_states' on the x-axis and 'performance' on the y-axis.
# The default style is a straight line connecting each data point.

plt.title("AI Performance Over States")
# Sets the title of the plot to "AI Performance Over States".

plt.xlabel("Game State")
# Labels the x-axis as "Game State".

plt.ylabel("Performance")
# Labels the y-axis as "Performance".

plt.show()
# Renders and displays the figure in a new window or inline, depending on the environment.

        </pre>

        <h2>18. Advanced Tips for AI Game Development</h2>
        <ul>
            <li><strong>Logging:</strong> Use the <code>logging</code> library to keep track of game events and AI
                decisions.</li>
            <li><strong>Visualization:</strong> Integrate libraries like <code>plotly</code> for interactive
                visualizations.</li>
            <li><strong>Optimization:</strong> Profile your code using <code>%prun</code> to identify bottlenecks.</li>
        </ul>

        <h2>19. Practice Exercises</h2>
        <ol>
            <li>
                Build a basic Pong game using <code>pygame</code> and implement AI for one of the paddles.
                <details>
                    <summary>Show/Hide Solution (Step-by-Step)</summary>
                    <ol>
                        <li><strong>Set up the Pong environment:</strong>
                            <pre class="python-code">
import pygame  # Imports the Pygame library, which provides functionalities to create games/graphics in Python
import sys     # Imports the sys library to handle system-specific parameters and functions (e.g., exiting the game)

pygame.init()  # Initializes all imported Pygame modules

# -----------------------
# Screen dimensions
# -----------------------
width, height = 800, 400
# width = 800  -> The horizontal size of the game window in pixels
# height = 400 -> The vertical size of the game window in pixels
# Example: If you want a smaller window, you could do: width, height = 600, 300

screen = pygame.display.set_mode((width, height))
# Creates the display window (or screen) where all game visuals are rendered
# Example: pygame.display.set_mode((1024, 768)) to create a 1024x768 window

pygame.display.set_caption("Pong AI")
# Sets the window title to "Pong AI"
# This is what you'll see at the top of the window or in the taskbar

# -----------------------
# Define game objects (paddles, ball)
# -----------------------
paddle_width, paddle_height = 10, 60
# paddle_width = 10  -> The thickness of the paddle
# paddle_height = 60 -> The height of the paddle
# Example: Make larger paddles with: paddle_width, paddle_height = 20, 100

player_x, player_y = 50, height // 2 - paddle_height // 2
# Positions the player paddle near the left side of the screen
# player_x = 50 means the paddle is placed 50 pixels from the left edge
# player_y = height // 2 - paddle_height // 2 places the paddle vertically centered

ai_x, ai_y = width - 50, height // 2 - paddle_height // 2
# Positions the AI paddle near the right side of the screen
# ai_x = width - 50 means the paddle is placed 50 pixels from the right edge
# ai_y is also centered vertically (same math as the player paddle)

ball_x, ball_y = width // 2, height // 2
# Places the ball at the center of the screen
# If you want the ball to start near the top-left corner, you could do: ball_x, ball_y = 50, 50

ball_speed_x, ball_speed_y = 4, 4
# Horizontal and vertical speed of the ball
# ball_speed_x = 4 (moves the ball 4 pixels to the right each frame)
# ball_speed_y = 4 (moves the ball 4 pixels down each frame)
# Example: If you want a faster ball, you might set ball_speed_x, ball_speed_y = 8, 8

player_speed = 0
# Vertical speed for the player paddle
# Initially 0, meaning the paddle won't move until you change this value during gameplay (e.g., when a key is pressed)

ai_speed = 4
# Vertical speed for the AI paddle
# Higher values make the AI paddle move up or down faster

clock = pygame.time.Clock()
# Creates a Clock object used to track and control the game's frame rate
# Example usage:
#   clock.tick(60) inside your main loop -> tries to cap the game at 60 frames per second

running = True
# A Boolean flag to keep the main game loop running
# When set to False, the game will exit
                            </pre>
                        </li>
                        <li><strong>Implement Player Movement:</strong> Capture keyboard events to move the
                            human-controlled paddle up/down.</li>
                        <li><strong>Add AI Logic for Opponent Paddle:</strong>
                            <ul>
                                <li>Track the ball's <code>y</code> position.</li>
                                <li>Move the AI paddle up or down to match the ball's <code>y</code> position.</li>
                            </ul>
                            <pre class="python-code">
# AI tries to follow the ball's y-coordinate
if ai_y + paddle_height//2 < ball_y:
    ai_y += ai_speed
elif ai_y + paddle_height//2 > ball_y:
    ai_y -= ai_speed
                            </pre>
                        </li>
                        <li><strong>Handle Ball Movement and Collisions:</strong> Bounce the ball off walls and paddles.
                        </li>
                        <li><strong>Run the Game Loop:</strong> Keep updating positions, checking for collisions, and
                            redrawing all elements until the user quits.</li>
                    </ol>
                    <p>
                        By adjusting <code>ai_speed</code> and adding more complex tracking (e.g., predictive AI),
                        you can make the AI more challenging.
                    </p>
                </details>
            </li>
            <li>
                Visualize the decision tree of a minimax algorithm using <code>networkx</code>.
                <details>
                    <summary>Show/Hide Solution (Step-by-Step)</summary>
                    <ol>
                        <li><strong>Install NetworkX:</strong>
                            <pre>!pip install networkx</pre>
                        </li>
                        <li><strong>Generate the Decision Tree:</strong> During the minimax recursion, record
                            each node (game state) and its children in a structure (like a dictionary).</li>
                        <li><strong>Create a Directed Graph:</strong>
                            <pre class="python-code">
import networkx as nx
import matplotlib.pyplot as plt

def build_tree(state, depth, graph, parent=None):
    # Example function that builds a tree recursively
    if depth == 0:
        return
    
    # Add this state as a node in the graph
    graph.add_node(state)
    if parent:
        graph.add_edge(parent, state)
    
    # For each child state, recursively build the tree
    child_states = get_children(state)
    for child in child_states:
        build_tree(child, depth-1, graph, parent=state)

# Example usage:
G = nx.DiGraph()
initial_state = "Root"
build_tree(initial_state, 3, G)
nx.draw(G, with_labels=True)
plt.show()
                            </pre>
                        </li>
                        <li><strong>Draw the Graph:</strong> Use <code>nx.draw()</code> or other layout functions to
                            visualize the resulting tree.</li>
                    </ol>
                    <p>
                        This approach helps you understand how the minimax algorithm explores different game states.
                    </p>
                </details>
            </li>
            <li>
                Create a learning agent for a maze-solving game using Q-learning.
                <details>
                    <summary>Show/Hide Solution (Step-by-Step)</summary>
                    <ol>
                        <li><strong>Set Up the Maze Environment:</strong> Represent the maze as a grid. Define actions
                            (up, down, left, right) and rewards (e.g., +1 for reaching the goal, -1 for hitting a wall).
                        </li>
                        <li><strong>Initialize Q-Table:</strong>
                            <pre class="python-code">
import numpy as np

num_states = ...  # e.g., width * height of maze
num_actions = 4   # up, down, left, right
Q = np.zeros((num_states, num_actions))
                            </pre>
                        </li>
                        <li><strong>Choose Hyperparameters:</strong> e.g., <code>learning_rate</code>,
                            <code>discount_factor</code>, and <code>epsilon</code> for exploration.
                        </li>
                        <li><strong>Update Rules:</strong> On each step, update Q-values using the Bellman equation:
                            <pre class="python-code">
Q[state, action] = Q[state, action] + learning_rate * (
    reward + discount_factor * np.max(Q[new_state, :]) - Q[state, action]
)
                            </pre>
                        </li>
                        <li><strong>Train the Agent:</strong> Run multiple episodes of the maze solver, updating the
                            Q-table until convergence.</li>
                        <li><strong>Test the Agent:</strong> After training, let the agent navigate the maze without
                            exploration (greedy action selection).</li>
                    </ol>
                    <p>
                        Over time, the agent learns an optimal policy to solve the maze. Adjust hyperparameters and
                        maze complexity to fine-tune performance.
                    </p>
                </details>
            </li>
        </ol>

        <!-- ********************************************
             NEW SECTION: BASIC MACHINE LEARNING EXAMPLE
             ******************************************** -->
        <h2>20. Basic Machine Learning Example with scikit-learn</h2>
        <p>This example demonstrates how to load a dataset using <code>scikit-learn</code>, split the data, train a
            logistic regression model, and evaluate its performance. Comments are provided for clarity.</p>
        <pre class="python-code">
# ---------------------------------------
# Import necessary libraries and modules
# ---------------------------------------
import numpy as np  # NumPy for numerical computing
from sklearn.datasets import load_iris  # Load sample iris dataset
from sklearn.model_selection import train_test_split  # For splitting data into train/test sets
from sklearn.linear_model import LogisticRegression  # Our ML model for classification
from sklearn.metrics import accuracy_score  # Evaluate how well the model performs

# -----------------------------------------------------
# 1. Load the iris dataset
#    - 'load_iris()' returns an object with both data and target
# -----------------------------------------------------
iris = load_iris()  # iris is a Bunch object containing data and target
X = iris.data       # X holds the features (sepal length, sepal width, etc.)
y = iris.target     # y holds the labels (types of iris flowers)

# ---------------------------------------------------------------------
# 2. Split the dataset into training and test sets
#    - 'train_test_split' divides data into two subsets
#    - 'test_size=0.2' reserves 20% of data for testing
#    - 'random_state=42' ensures reproducible shuffling
# ---------------------------------------------------------------------
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# ----------------------------------------------------
# 3. Initialize the Logistic Regression model
#    - 'max_iter=200' allows more iterations for solver
# ----------------------------------------------------
model = LogisticRegression(max_iter=200)

# -----------------------------------------------
# 4. Train (fit) the model on the training data
#    - 'fit' uses X_train and y_train to learn
# -----------------------------------------------
model.fit(X_train, y_train)

# ---------------------------------------------
# 5. Predict on the test set
#    - 'predict' generates labels on unseen data
# ---------------------------------------------
y_pred = model.predict(X_test)

# -----------------------------------------------
# 6. Calculate the accuracy of the model
#    - 'accuracy_score' compares predictions to true labels
# -----------------------------------------------
accuracy = accuracy_score(y_test, y_pred)

# -------------------------
# 7. Print the test accuracy
# -------------------------
print("Test Accuracy:", accuracy)
        </pre>

        <div class="note">
            <p><strong>Tip:</strong> Explore the official <a href="https://jupyterlab.readthedocs.io/"
                    target="_blank">Jupyter Lab documentation</a> for more features and examples.</p>
        </div>
    </div>

    <footer>
        <p>University of North Dakota CSCI 384</p>
    </footer>
</body>

</html>